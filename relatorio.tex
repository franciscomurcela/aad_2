\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}

\geometry{margin=2.5cm}

% Configuração para código VHDL
\lstdefinestyle{vhdl}{
    language=VHDL,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    frame=single,
    breaklines=true,
    captionpos=b
}

\title{\textbf{AAD Second Practice Assignment}}
\author{Francisco Murcela - 108815}
\date{01/2026 \\ Universidade de Aveiro - DETI}

\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

\section{Introdução}

Este relatório descreve o desenvolvimento e implementação do segundo trabalho prático da unidade curricular de Arquitetura Avançada de Dispositivos (AAD). O objetivo principal do trabalho consistiu na implementação de três componentes digitais em VHDL: um comparador de N bits, um \textit{barrel shifter} e uma unidade de extração de campos de bits (BFE - \textit{Bit Field Extract}).

O trabalho foi desenvolvido utilizando ferramentas \textit{open-source} para síntese, simulação e visualização de circuitos digitais, nomeadamente o GHDL (compilador e simulador VHDL) e o GTKWave (visualizador de formas de onda).

\section{Enunciado e Objetivos}

O trabalho prático consistiu na implementação de três componentes digitais distintos, cada um com requisitos específicos:

\subsection{Comparador de N bits}

O primeiro componente a implementar foi um comparador genérico de N bits capaz de comparar dois valores binários e produzir três sinais de saída:
\begin{itemize}
    \item \texttt{lt}: sinal ativo quando $a < b$
    \item \texttt{eq}: sinal ativo quando $a = b$
    \item \texttt{gt}: sinal ativo quando $a > b$
\end{itemize}

O comparador deveria ser implementado utilizando a biblioteca \texttt{numeric\_std} do IEEE e considerar atrasos de propagação realistas: 10 ps base mais 2N ps para as comparações de maior/menor, e apenas 10 ps para a comparação de igualdade.

\subsection{Barrel Shift Right}

O segundo componente consistiu num \textit{barrel shifter} capaz de realizar deslocamentos à direita de forma configurável. Este componente deveria suportar:
\begin{itemize}
    \item Deslocamento lógico (preenchimento com zeros)
    \item Deslocamento aritmético (preservação do bit de sinal)
    \item Quantidade de deslocamento variável (0 a 15 bits para DATA\_BITS\_LOG2=4)
\end{itemize}

A implementação deveria ser feita de forma estrutural, utilizando múltiplos estágios de \textit{shift slices} em cascata, onde cada estágio realiza um deslocamento condicional de $2^i$ bits.

\subsection{Bit Field Extract (BFE)}

O componente mais complexo do trabalho foi o BFE, que implementa a funcionalidade de extração de campos de bits de uma palavra. Esta operação é comum em processadores modernos e permite extrair um conjunto consecutivo de bits de uma posição arbitrária. O componente deveria suportar:
\begin{itemize}
    \item Extração \textit{unsigned} (preenchimento com zeros)
    \item Extração \textit{signed} (extensão de sinal)
    \item Posição inicial e tamanho configuráveis
\end{itemize}

A implementação deveria ser estrutural, integrando o \textit{barrel shifter} e múltiplos comparadores para gerar as máscaras necessárias.

\section{Desenvolvimento}

\subsection{Ambiente de Desenvolvimento}

Para o desenvolvimento deste trabalho foram utilizadas as seguintes ferramentas:

\textbf{GHDL (v5.1.1):} Compilador e simulador \textit{open-source} para VHDL, compatível com o padrão VHDL-2008. O GHDL foi utilizado para analisar, compilar e simular todos os componentes desenvolvidos, gerando ficheiros VCD (\textit{Value Change Dump}) com as formas de onda resultantes.

\textbf{GTKWave (v3.3.100):} Visualizador de formas de onda \textit{open-source} que permite analisar graficamente os resultados das simulações. Esta ferramenta foi essencial para verificar visualmente o comportamento correto dos circuitos implementados.

\textbf{Sistema Operativo:} Windows 10/11 com PowerShell para execução dos comandos de compilação e simulação.

\subsection{Implementação do Comparador}

O comparador de N bits foi implementado utilizando uma arquitetura comportamental simples, aproveitando os operadores de comparação da biblioteca \texttt{numeric\_std}. A implementação inclui sinais internos com atrasos de propagação que simulam o comportamento real de um comparador digital.

O código VHDL utiliza conversões para o tipo \texttt{unsigned} para as comparações de maior e menor, permitindo que os valores sejam interpretados como números binários sem sinal. Para a comparação de igualdade, a comparação direta dos vetores \texttt{std\_logic\_vector} é suficiente.

Os atrasos foram implementados utilizando o comando \texttt{transport}, que permite especificar com precisão os tempos de propagação dos sinais através do circuito.

\subsection{Implementação do Barrel Shifter}

O \textit{barrel shifter} foi implementado de forma estrutural, utilizando múltiplos estágios de deslocamento em cascata. Cada estágio é responsável por um deslocamento condicional de $2^i$ bits, onde $i$ varia de 0 a DATA\_BITS\_LOG2-1.

O componente auxiliar \texttt{shift\_right\_slice} implementa um estágio individual de deslocamento. Este componente recebe:
\begin{itemize}
    \item \texttt{data\_in}: dados de entrada (16 bits)
    \item \texttt{sel}: seleção (0 = sem deslocamento, 1 = aplicar deslocamento)
    \item \texttt{missing}: bit a inserir nas posições vazias
\end{itemize}

A interligação dos múltiplos estágios permite que qualquer quantidade de deslocamento (0-15 bits) seja realizada de forma eficiente, utilizando apenas 4 estágios em cascata.

\subsection{Implementação do BFE}

O componente BFE foi implementado seguindo uma arquitetura estrutural que integra os componentes anteriores. O fluxo de dados segue os seguintes passos:

\begin{enumerate}
    \item \textbf{Deslocamento à direita:} O valor de entrada é deslocado à direita pela quantidade especificada em \texttt{start}, alinhando o campo de bits desejado à posição menos significativa.
    
    \item \textbf{Geração de máscara:} São utilizados múltiplos comparadores (16 no total) para gerar uma máscara binária. Cada bit da máscara é determinado comparando o índice do bit com o valor de \texttt{size}.
    
    \item \textbf{Aplicação da máscara:} A máscara gerada é aplicada ao valor deslocado através de uma operação AND bit-a-bit, isolando apenas o campo de bits desejado.
    
    \item \textbf{Extensão de sinal:} Se o modo \texttt{signed} estiver ativo e o bit de sinal do campo extraído for 1, os bits mais significativos são preenchidos com 1s através de uma operação OR com uma máscara invertida.
\end{enumerate}

\section{Testes e Validação}

Para cada componente foi desenvolvido um \textit{testbench} que aplica diversos casos de teste e verifica os resultados esperados.

\subsection{Teste do Comparador}

O \textit{testbench} do comparador aplica cinco casos de teste distintos:
\begin{itemize}
    \item $a=2, b=2$ (igualdade)
    \item $a=11, b=4$ (maior)
    \item $a=5, b=10$ (menor)
    \item $a=7, b=7$ (igualdade)
    \item $a=15, b=14$ (maior)
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{comparator_n_waveform.png}
    \caption{Formas de onda do comparador de 4 bits. Os sinais \texttt{eq}, \texttt{gt} e \texttt{lt} ativam-se conforme esperado para cada caso de teste.}
    \label{fig:comparator}
\end{figure}

Os resultados da simulação (Figura \ref{fig:comparator}) confirmam o funcionamento correto do comparador. Observa-se que:
\begin{itemize}
    \item O sinal \texttt{eq} ativa-se apenas quando $a=b$
    \item O sinal \texttt{gt} ativa-se apenas quando $a>b$
    \item O sinal \texttt{lt} ativa-se apenas quando $a<b$
    \item Os atrasos de propagação são visíveis no início da simulação
\end{itemize}

\subsection{Teste do Barrel Shifter}

O \textit{testbench} do \textit{barrel shifter} realiza dois ciclos de testes:
\begin{itemize}
    \item \textbf{Primeiro ciclo:} Entrada \texttt{0x7FFF}, testando todos os deslocamentos de 0 a 15 bits, tanto em modo lógico como aritmético
    \item \textbf{Segundo ciclo:} Entrada \texttt{0xFFFF}, repetindo os mesmos testes
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{barrel_shift_waveform.png}
    \caption{Formas de onda do \textit{barrel shifter}. Observa-se a diferença entre deslocamento lógico (preenchimento com 0) e aritmético (preservação do bit de sinal).}
    \label{fig:barrel}
\end{figure}

A Figura \ref{fig:barrel} mostra os resultados para o segundo ciclo de testes. Quando a entrada é \texttt{0xFFFF}:
\begin{itemize}
    \item No modo lógico (\texttt{missing=0}), os bits mais significativos são preenchidos com zeros, resultando em valores decrescentes
    \item No modo aritmético (\texttt{missing=1}), o bit de sinal é preservado, mantendo o valor \texttt{0xFFFF} em todos os deslocamentos
\end{itemize}

\subsection{Teste do BFE}

O \textit{testbench} do BFE aplica múltiplos casos de teste com valores reais para validar completamente a extração de campos de bits. Os testes incluem:

\begin{itemize}
    \item Extração de 4 bits começando na posição 3 de \texttt{0xABCD}: resultado esperado \texttt{0x0009} (unsigned) e \texttt{0xFFF9} (signed, com extensão de sinal)
    \item Extração de 8 bits começando na posição 4 de \texttt{0xDEAD}: resultado \texttt{0x00EA}
    \item Extração de 3 bits começando na posição 0 de \texttt{0x1234}: resultado \texttt{0x0004}
    \item \textbf{Caso limite:} Extração de 8 bits começando na posição 10 de \texttt{0xFFFF}: testa a condição $start + size > 15$, onde os bits inexistentes devem ser preenchidos com zeros
    \item Extração de campos de 1 bit para testar a granularidade mínima
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{bfe_improved_waveform.png}
    \caption{Formas de onda do BFE com valores reais. Observa-se claramente a extração de campos de bits, o funcionamento das máscaras dinâmicas e a diferença entre modo unsigned e signed.}
    \label{fig:bfe}
\end{figure}

A Figura \ref{fig:bfe} demonstra o funcionamento correto do BFE. Pontos importantes:
\begin{itemize}
    \item O valor \texttt{src} varia entre diferentes padrões (\texttt{0xABCD}, \texttt{0xDEAD}, etc.)
    \item A saída \texttt{dst} apresenta os campos extraídos corretamente alinhados à direita
    \item No modo \texttt{signed} (\texttt{variant=1}), quando o bit de sinal do campo extraído é 1, os bits superiores são preenchidos com 1s
    \item O sinal \texttt{shifted\_src} mostra o resultado intermédio após o \textit{barrel shift}
    \item As máscaras (\texttt{mask}) são geradas dinamicamente conforme o valor de \texttt{size}
    \item O caso limite $start + size > 15$ é corretamente tratado, preenchendo as posições inexistentes com zeros
\end{itemize}

\section{Análise de Performance}

\subsection{Cálculo do Caminho Crítico}

O enunciado solicita a determinação do menor período de relógio funcional para a implementação do BFE. Para tal, é necessário identificar o caminho crítico (maior atraso de propagação) através de todos os componentes.

\subsubsection{Atrasos dos Componentes Individuais}

\textbf{Comparador de N bits (N=4):}
\begin{itemize}
    \item Comparações de maior/menor (\texttt{lt}, \texttt{gt}): $10 + 2N = 10 + 8 = 18$ ps
    \item Comparação de igualdade (\texttt{eq}): $10$ ps
\end{itemize}

\textbf{Shift Right Slice:}
\begin{itemize}
    \item Atraso por estágio: $10$ ps
\end{itemize}

\textbf{Barrel Shift Right (4 estágios em cascata):}
\begin{itemize}
    \item Atraso total: $4 \times 10 = 40$ ps
\end{itemize}

\subsubsection{Caminho Crítico do BFE}

O caminho crítico do componente BFE segue o seguinte fluxo de dados:

\begin{enumerate}
    \item \textbf{Barrel Shifter:} Desloca os dados de entrada pela quantidade especificada em \texttt{start}
    \begin{itemize}
        \item Atraso: $40$ ps (4 estágios $\times$ 10 ps/estágio)
    \end{itemize}
    
    \item \textbf{Geração de Máscara (16 comparadores em paralelo):} Os comparadores determinam quais bits devem ser mantidos
    \begin{itemize}
        \item Atraso: $18$ ps (comparação "menor que")
        \item \textit{Nota:} Estes comparadores operam em paralelo, logo o atraso não se acumula 16 vezes
    \end{itemize}
    
    \item \textbf{Aplicação da Máscara:} Operação AND bit-a-bit entre dados deslocados e máscara
    \begin{itemize}
        \item Atraso: $\sim 5$ ps (operação combinacional simples)
    \end{itemize}
    
    \item \textbf{Determinação do Bit de Sinal:} Processo combinacional que identifica o MSB do campo extraído
    \begin{itemize}
        \item Atraso: $\sim 10$ ps (multiplexador e lógica de seleção)
    \end{itemize}
    
    \item \textbf{Extensão de Sinal:} Operação OR condicional para preencher bits superiores
    \begin{itemize}
        \item Atraso: $\sim 5$ ps (operação combinacional)
    \end{itemize}
\end{enumerate}

\textbf{Atraso Total do Caminho Crítico:}
\begin{equation}
T_{critical} = 40 + 18 + 5 + 10 + 5 = 78 \text{ ps}
\end{equation}

\subsubsection{Período Mínimo de Relógio}

Considerando o atraso do caminho crítico e uma margem de segurança de aproximadamente 30\% para variações de processo, temperatura e tensão (PVT), bem como \textit{setup/hold times} dos registos:

\begin{equation}
T_{clock\_min} = 1.3 \times T_{critical} = 1.3 \times 78 = 101.4 \text{ ps} \approx 100 \text{ ps}
\end{equation}

\textbf{Frequência Máxima de Operação:}
\begin{equation}
f_{max} = \frac{1}{T_{clock\_min}} = \frac{1}{100 \times 10^{-12}} = 10 \text{ GHz}
\end{equation}

Este valor representa a frequência teórica máxima para a implementação puramente combinacional. Na prática, numa implementação em FPGA ou ASIC real, seriam necessários registos entre os estágios principais (técnica de \textit{pipelining}) para atingir frequências tão elevadas, reduzindo o atraso por estágio mas aumentando a latência total.

\section{Resultados e Conclusões}

O trabalho foi concluído com sucesso, tendo sido implementados todos os componentes solicitados. As simulações com valores reais confirmaram o funcionamento correto de cada componente individualmente e da integração entre eles no caso do BFE.

\subsection{Conclusões Técnicas}

A implementação deste trabalho permitiu consolidar conhecimentos sobre:
\begin{itemize}
    \item Descrição de hardware em VHDL, utilizando tanto estilos comportamentais como estruturais
    \item Utilização de \textit{generics} para criar componentes parametrizáveis e reutilizáveis
    \item Modelação de atrasos de propagação em circuitos digitais e análise de \textit{timing}
    \item Identificação e cálculo do caminho crítico em circuitos combinacionais complexos
    \item Metodologia de desenvolvimento baseada em \textit{testbenches} abrangentes para validação
    \item Importância de testar casos limite (ex: $start + size > 15$) para garantir robustez
    \item Utilização de ferramentas \textit{open-source} (GHDL e GTKWave) para desenvolvimento de hardware
\end{itemize}

\textbf{Resultados Quantitativos:}
\begin{itemize}
    \item Caminho crítico do BFE: 78 ps
    \item Período mínimo de relógio (com margem): 100 ps
    \item Frequência máxima teórica: 10 GHz
    \item Todos os testes passaram com sucesso, incluindo casos limite
\end{itemize}

A implementação estrutural do BFE demonstrou como componentes simples (comparadores e \textit{barrel shifters}) podem ser combinados para criar funcionalidades complexas. O uso de múltiplos comparadores em paralelo para gerar a máscara de forma dinâmica é uma solução elegante que evita lógica condicional complexa.


\section{Referências}

\begin{itemize}
    \item GHDL Documentation: \url{https://ghdl.github.io/ghdl/}
    \item GTKWave Documentation: \url{http://gtkwave.sourceforge.net/}
\end{itemize}

\end{document}
